GUI library:

graph
    bitblt()
    rectangle()
    string()

font
    text_size()
    get_glyph()
    cache_glyph()

widget
    parent()
    pos()
    move()

layout
    set_spacing()
    set_layout_orient()
    set_desired_size()
    fit_elements()
        - union childs sizes
        - arrange elements with desired spacing

GUI
    draw()
    update()
    set_style()
    create_widget()

// window tree
window
    vert_slider
        text_area
        hor_slider
            button1
            button2

// draw
for(layer : overlays)
    for(window : layer)
        window.draw(vertex_buffer, text_buffer, layer)

struct CtrlAttrs {
    float width;
    float width_min;
    float width_max;
    float height;
    float height_min;
    float height_max;
    float layout_spacing;
    float layout_wrap_spacing;
    VuiBool layout_wrap;
    VuiVec2 offset;
    VuiAlign align;
    VuiImageScaleMode image_scale_mode;
    float style_transition_time;
};

typedef struct {
    VuiVec2 pos;
    VuiVec2 uv;
    VuiColor color;
} VuiVertexT;


//gtec-demo-framework-4.0.0
struct NineSlice
  {
  private:
    int32_t m_sliceFromTopLeftX;
    int32_t m_sliceFromTopLeftY;
    int32_t m_sliceFromBottomRightX;
    int32_t m_sliceFromBottomRightY;
  public:
    NineSlice()
      : m_sliceFromTopLeftX(0)
      , m_sliceFromTopLeftY(0)
      , m_sliceFromBottomRightX(0)
      , m_sliceFromBottomRightY(0)
    {
    }

    //! @brief Create the slice points based on a rectangle
    NineSlice(const int32_t sliceFromTopLeftX, const int32_t sliceFromTopLeftY, const int32_t sliceFromBottomRightX, const int32_t sliceFromBottomRightY);

    inline int32_t SliceFromTopLeftX() const { return m_sliceFromTopLeftX; }
    inline int32_t SliceFromTopLeftY() const { return m_sliceFromTopLeftY; }
    inline int32_t SliceFromBottomRightX() const { return m_sliceFromBottomRightX; }
    inline int32_t SliceFromBottomRightY() const { return m_sliceFromBottomRightY; }

    bool operator==(const NineSlice& rhs) const { return m_sliceFromTopLeftX == rhs.m_sliceFromTopLeftX && m_sliceFromTopLeftY == rhs.m_sliceFromTopLeftY && m_sliceFromBottomRightX == rhs.m_sliceFromBottomRightX && m_sliceFromBottomRightY == rhs.m_sliceFromBottomRightY; }
    bool operator!=(const NineSlice& rhs) const { return !(*this == rhs); }

    inline int32_t SumX() const { return m_sliceFromTopLeftX + m_sliceFromBottomRightX; }
    inline int32_t SumY() const { return m_sliceFromTopLeftY + m_sliceFromBottomRightY; }

    inline bool IsEmpty() const { return (m_sliceFromTopLeftX + m_sliceFromTopLeftY + m_sliceFromBottomRightX + m_sliceFromBottomRightY) == 0; }
  };
  
     //! @brief Since we have multiple controls that need this code its been isolated here as inline methods
    namespace Draw9SliceImpl
    {
      inline static void WinDraw(const std::shared_ptr<INativeBatch2D>& batch2D, const Rect& dstRect, const AtlasTexture2D& texture, const NineSlice& nineSlice, const ThicknessF& minimumBackgroundMargin, const Color& color)
      {
        if (!texture.IsValid())
          return;

        const Point2 textureSize = texture.GetSize();
        if (textureSize.X < nineSlice.SumX() || textureSize.Y < nineSlice.SumY())
        {
          FSLLOG_WARNING("The nine slice is incompatible with the image");
          return;
        }

        // Quick handling of a empty nine slice (this means we just draw the center piece)
        if (nineSlice.IsEmpty())
        {
          batch2D->Draw(texture, dstRect, Color::White());
          return;
        }

        //if (nineSlice.IsEmpty())
        //{

        //  return;
        //}


        // A  B              C  D
        //--------------------------------------------------------------------------------------------------------------------------------------------
        // |  |              |  |
        // |  |              |  |
        // |--------------------|   B
        // |  |              |  |
        // |  |              |  |
        // |  |              |  |
        // |--------------------|   C
        // |  |              |  |
        // |  |              |  |
        //--------------------------------------------------------------------------------------------------------------------------------------------

        const int32_t srcLeftWidth = nineSlice.SliceFromTopLeftX();
        const int32_t srcTopHeight = nineSlice.SliceFromTopLeftY();
        const int32_t srcCenterWidth = textureSize.X - nineSlice.SumX();
        const int32_t srcCenterHeight = textureSize.Y - nineSlice.SumY();
        const int32_t srcRightWidth = nineSlice.SliceFromBottomRightX();
        const int32_t srcBottomHeight = nineSlice.SliceFromBottomRightY();

        const float rect0Width = static_cast<float>(srcLeftWidth);
        const float rect0Height = static_cast<float>(srcTopHeight);
        const float rect4Width = static_cast<float>(srcCenterWidth);
        const float rect4Height = static_cast<float>(srcCenterHeight);
        const float rect8Width = static_cast<float>(srcRightWidth);
        const float rect8Height = static_cast<float>(srcBottomHeight);

        float bgLeft = std::max(rect0Width, minimumBackgroundMargin.Left());
        float bgTop = std::max(rect0Height, minimumBackgroundMargin.Top());
        float bgRight = std::max(rect8Width, minimumBackgroundMargin.Right());
        float bgBottom = std::max(rect8Height, minimumBackgroundMargin.Bottom());
        float bgSizeX = bgLeft + bgRight + rect4Width;
        float bgSizeY = bgTop + bgBottom + rect4Height;
        {
          Vector2 bgScale;
          if (!UIScaleUtil::TryCalcScaling(bgScale, dstRect.GetSize(), Vector2(bgSizeX, bgSizeY), ItemScalePolicy::DownscaleKeepAR))
            return;

          bgLeft *= bgScale.X;
          bgRight *= bgScale.X;
          bgTop *= bgScale.Y;
          bgBottom *= bgScale.Y;
        }

        const float dstXA = dstRect.Left();
        const float dstYA = dstRect.Top();
        const float dstXB = dstXA + bgLeft;
        const float dstYB = dstYA + bgTop;
        const float dstXD = dstRect.Right();
        const float dstYD = dstRect.Bottom();
        const float dstXC = dstXD - bgRight;
        const float dstYC = dstYD - bgBottom;

        Rect finalDstRect;

        batch2D->ChangeTo(BlendState::AlphaBlend);

        const int32_t srcRightStart = srcLeftWidth + srcCenterWidth;
        const int32_t srcBottomStart = srcTopHeight + srcCenterHeight;


        // TOP_LEFT CORNER: xa, ya, xb, yb
        finalDstRect = Rect(dstXA, dstYA, dstXB, dstYB, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(0, 0, srcLeftWidth, srcTopHeight), color);

        // TOP: xb, ya, xc, yb
        finalDstRect = Rect(dstXB, dstYA, dstXC, dstYB, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(srcLeftWidth, 0, srcCenterWidth, srcTopHeight), color);

        // TOP_RIGHT CORNER: xc, ya, xd, yb
        finalDstRect = Rect(dstXC, dstYA, dstXD, dstYB, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(srcRightStart, 0, srcRightWidth, srcTopHeight), color);

        // LEFT SIDE: xa, yb, xb, yc
        finalDstRect = Rect(dstXA, dstYB, dstXB, dstYC, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(0, srcTopHeight, srcLeftWidth, srcCenterHeight), color);

        // CENTER: xb, yb, xc, yc
        finalDstRect = Rect(dstXB, dstYB, dstXC, dstYC, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(srcLeftWidth, srcTopHeight, srcCenterWidth, srcCenterHeight), color);

        // RIGHT SIDE: xc, yb, xd, yc
        finalDstRect = Rect(dstXC, dstYB, dstXD, dstYC, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(srcRightStart, srcTopHeight, srcRightWidth, srcCenterHeight), color);

        // BOTTOM_LEFT CORNER: xa, yc, xb, yd
        finalDstRect = Rect(dstXA, dstYC, dstXB, dstYD, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(0, srcBottomStart, srcLeftWidth, srcBottomHeight), color);

        // BOTTOM: xb, yc, xc, yd
        finalDstRect = Rect(dstXB, dstYC, dstXC, dstYD, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(srcLeftWidth, srcBottomStart, srcCenterWidth, srcBottomHeight), color);

        // BOTTOM_RIGHT CORNER: xc, yc, xd, yd
        finalDstRect = Rect(dstXC, dstYC, dstXD, dstYD, false);
        batch2D->Draw(texture, finalDstRect, Rectangle(srcRightStart, srcBottomStart, srcRightWidth, srcBottomHeight), color);
      }
    }
    
    bool UIScaleUtil::TryCalcScaling(Vector2& rScaling, const Vector2& targetSize, const Vector2& srcSize, const ItemScalePolicy scalePolicy)
    {
      rScaling = Vector2();
      if (srcSize.X <= 0.0f || srcSize.Y <= 0.0f)
        return false;

      Vector2 newSize;
      if (!TryCalcSize(newSize, targetSize, srcSize, scalePolicy))
        return false;

      rScaling = !EqualHelper::IsAlmostEqual(newSize, srcSize) ? Vector2((newSize.X / srcSize.X), (newSize.Y / srcSize.Y)) : Vector2(1.0f, 1.0f);
      return true;
    }
    
    bool UIScaleUtil::TryCalcSize(Vector2& rSize, const Vector2& targetSize, const Vector2& srcSize, const ItemScalePolicy scalePolicy)
    {
      rSize = Vector2();
      if (srcSize.X <= 0.0f || srcSize.Y <= 0.0f)
        return false;

      Vector2 size = CalcSize(targetSize, srcSize, scalePolicy);
      if (size.X < 0 || size.Y < 0)
        return false;

      rSize = size;
      return true;
    }
    
    Vector2 UIScaleUtil::CalcSize(const Vector2& targetSize, const Vector2& srcSize, const ItemScalePolicy scalePolicy)
    {
      assert(!isnan(targetSize.X));
      assert(!isnan(targetSize.Y));
      assert(!isnan(srcSize.X));
      assert(!isnan(srcSize.Y));
      assert(targetSize.X >= 0.0f);
      assert(targetSize.Y >= 0.0f);
      assert(targetSize.X < CONSIDER_POSITIVE_INFINITY);
      assert(targetSize.Y < CONSIDER_POSITIVE_INFINITY);
      assert(srcSize.X < CONSIDER_POSITIVE_INFINITY);
      assert(srcSize.Y < CONSIDER_POSITIVE_INFINITY);

      const Vector2 clampedTarget(std::max(targetSize.X, 0.0f), std::max(targetSize.Y, 0.0f));
      const Vector2 clampedSrc(srcSize.X <= 0.0f ? 0.0f : srcSize.X, srcSize.Y <= 0.0f ? 0.0f : srcSize.Y);

      // Early abort for no scaling
      if (clampedTarget == clampedSrc)
        return clampedTarget;

      switch (scalePolicy)
      {
      case ItemScalePolicy::NoScaling:
        return srcSize;
      case ItemScalePolicy::Fit:
        return clampedTarget;
      case ItemScalePolicy::Downscale:
        return Vector2(std::min(clampedTarget.X, clampedSrc.X), std::min(clampedTarget.Y, clampedSrc.Y));
      case ItemScalePolicy::FitKeepAR:
        return CalcSizeKeepAspectRatioScaling(clampedTarget, srcSize);
      case ItemScalePolicy::DownscaleKeepAR:
        return CalcSizeKeepAspectRatioDownScaling(clampedTarget, srcSize);
      default:
        FSLLOG_WARNING("Unsupported scaling policy, using src size");
        return srcSize;
      }
    }
    
    inline Vector2 CalcSizeKeepAspectRatioScaling(const Vector2& targetSize, const Vector2& srcSize)
      {
        assert(targetSize.X >= 0.0f);
        assert(targetSize.Y >= 0.0f);
        assert(targetSize.X < CONSIDER_POSITIVE_INFINITY);
        assert(targetSize.Y < CONSIDER_POSITIVE_INFINITY);
        assert(srcSize.X >= 0.0f);
        assert(srcSize.Y >= 0.0f);
        assert(srcSize.X < CONSIDER_POSITIVE_INFINITY);
        assert(srcSize.Y < CONSIDER_POSITIVE_INFINITY);

        if (srcSize.X < 0.00001f || srcSize.X < 0.00001f)
          return Vector2();
        if( targetSize.X <= 0.00001f || targetSize.Y <= 0.00001f )
          return Vector2();

        // m = dy / dx
        // y = m * x
        // x = y / m
        float m = srcSize.Y / srcSize.X;

        float calcedX = targetSize.Y / m;
        float calcedY = m * targetSize.X;
        if (calcedX <= 0.0001f || calcedY <= 0.000f )
          return Vector2();

        Vector2 size1(calcedX, targetSize.Y);
        Vector2 size2(targetSize.X, calcedY);
        // since we keep the aspect ratio the scaling factors will always be uniform
        return (size1.LengthSquared() < size2.LengthSquared() ? size1 : size2);
      }
      
